<html><?xml version="1.0" encoding="ISO-8859-1"?><!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>
	Referencia de Fenix
</title>
<style>
	body	{ font-family: Verdana; font-size: 15px }
	a	{ text-decoration: none; color: #c00000; font-weight: bold }
	a:hover { color: #ff6600 }
	thead	{ background: black; color: white; padding: 4pt }
	li	{ padding: 4pt; padding-left: 12pt }
	pre	{ padding: 8pt; padding-left: 12pt; border: solid black 1px; background-color: white; margin-right: 40px }
	td      { padding: 4pt; vertical-align: top; }
	th      { padding: 4pt; vertical-align: top; background: #E0E0F0; text-align: left; width: 200px }
	body    { background: #F0F0F0 }
</style>
</head>
<body>

	<form action="func.php-func=.htm" tppabs="http://fenix.jlceb.com/func.php?func=">
	<div style=" 
		color: #A0A0A0; 
		border: outset #600000 2px; 
		background: #660000;
		text-align: center; 
		vertical-align: middle;
		font-weight: bold;
		height: 24px;
		margin: 0px; ">
		[ <a style="color: white" href="func.php-funcs=^(dll-){0}.htm" tppabs="http://fenix.jlceb.com/func.php?funcs=^(dll/){0}">TODO</a> |
		  <a style="color: white" target="_top" href="func.php-frame=top.htm" tppabs="http://fenix.jlceb.com/func.php?frame=top">SECCIONES</a> |
		  <a style="color: white" target="_top" href="func.php-frame=top&dirs=^dll-.htm" tppabs="http://fenix.jlceb.com/func.php?frame=top&dirs=^dll/">DLLs</a> |
		  Buscar Función: <input name="func" size="15" onfocus="select()"/> ]
	</div>
	</form>
	
<script language="JavaScript">
<!--

function SymError()
{
  return true;
}

window.onerror = SymError;

//-->
</script>

<script> document.forms[0].func.focus() </script>
	<table cellspacing="8pt"><tr><td style="padding-left: 0pt"><font color=#800000><B> FBM</B> (Fenix BitMap)</font></td></tr>
 </td></tr> <tr><td style="padding-left: 40pt"> <p> Imágen o sprite opcionalmente animado </p> </td></tr>  <tr><td> <b>DESCRIPCIÓN</b> </td></tr> 
		           <tr><td style="padding-left: 40pt"> <P> Un fichero FBM contiene un gráfico sencillo, rectangular, con transparencia por <I> color key</I> (cada pixel de la imagen puede contener un color, o bien ser totalmente transparente, pero no se soporta un color con transparencia parcial).</P> <P> Esta sección describe el contenido de un fichero FBM. No es necesario conocer estos detalles simplemente para programar juegos, pero serán de utilidad a quien quiera realizar utilidades en lenguajes externos que lean o escriban ficheros FBM.</P> <P> Un fichero FBM no incluye compresión. Fenix soporta de forma transparente el uso de compresión GZIP en los ficheros, sin necesidad de marcarlos especialmente con extensión .gz. Normalmente un fichero FBM se guarda en disco comprimido de esta manera, pero en el resto del fichero asumiremos que el fichero FBM no está comprimido.</P> <P> En la descripción siguiente, DWORD identifica un número entero de 4 bytes sin signo mientras INT indica entero de 4 bytes con signo. Estos valores se guardan siguiendo la codificación Intel de bytes en memoria, así que hay que darles la vuelta al leer o escribir el fichero en otras plataformas.</P> <H3> Cabecera</H3> <P> Un fichero FBM comienza con la siguiente cabecera: <TABLE> <TR> <TH> MAGIC</TH> <TD> 16 bytes</TD> <TD> Cadena de caracteres de identificación del fichero. Debe contener exactamente "FenixBitmap" seguido de un espacio y, a continuación, los cuatro bytes 1Ah, 0Dh, 0Ah y 00h. Esta terminación indica, en un fichero MS-DOS, final de fichero. Gracias a ella un comando TYPE en MS-DOS no mostraría los datos binarios del fichero. En este formato se conserva por razones puramente nostálgicas.</TD></TR> <TR> <TH> VERSION</TH> <TD> DWORD</TD> <TD> Código de versión. Se compone de un número mayor de 16 bits y un número menor de 16 bits. Actualmente es 0x0100. Si el formato se modificase en el futuro pero de manera que los ficheros fuesen compatibles con el formato actual, se incrementaría el número menor. Las rutinas de carga deben rechazar un fichero FBM sólo si el número mayor no es 01.</TD></TR> <TR> <TH> PROFUNDIDAD</TH> <TD> DWORD</TD> <TD> Bits por pixel de la imagen. Actualmente sólo son válidos 1, 8 ó 16. Este valor modifica en cierta manera las secciones que aparecen a continuación (por ejemplo, un FBM de 8 bits siempre cuenta con una paleta de colores).</TD></TR></TABLE></P> <H3> Descriptor</H3> <P> Inmediatamente después de la cabecera aparece un bloque descriptor de 100 bytes de contenido fijo. Se puede interpretar como una extensión de la cabecera: <TABLE> <TR> <TH> NOMBRE</TH> <TD> 64 bytes</TD> <TD> Cadena ASCIIZ con el nombre del gráfico (opcional). El nombre puede ocupar exactamente 64 caracteres, con lo que sólo en ese caso no se guardará el 0 terminal.</TD></TR> <TR> <TH> ANCHO</TH> <TD> DWORD</TD> <TD> Ancho en pixels del gráfico. A partir de este ancho se puede calcular la cantidad de memoria en bytes que ocupa una fila del gráfico en disco, y que depende de la PROFUNDIDAD de la cabecera: <UL> <LI> Profundidad 1: (ancho+7) / 8 <BR></BR> redondeado hacia abajo. Las filas, al guardarse en disco, se incrementan con bits a cero hasta ocupar un número exacto de bytes, pero sólo si el ancho original no es ya múltiplo de 8.</LI> <LI> Profundidad 8: ancho</LI> <LI> Profundiad 16: ancho * 2</LI></UL></TD></TR> <TR> <TH> ALTO</TH> <TD> DWORD</TD> <TD> Alto en pixels del pixels del gráfico</TD></TR> <TR> <TH> FLAGS</TH> <TD> DWORD</TD> <TD> Esta posición se reserva para flags informativos sobre el contenido del gráfico. Por ahora sólo se reconoce el bit 0 de los flags: <UL> <LI> Bit 0: sirve para marcar gráficos sin pixels transparentes. Si en todo el contenido del gráfico no hay ningún pixel completamente a cero, este bit debe grabarse activado. Esto es independiente del uso que le quiera dar el programador (un gráfico con varios pixels a cero que se muestre usando el flag NO_COLOR_KEY para hacerlos visibles, seguiría teniendo a cero este bit).</LI></UL></TD></TR> <TR> <TH> ID</TH> <TD> DWORD</TD> <TD> Identificador del gráfico, de 0 a 999. Cuando el gráfico forma parte de una librería FGC, indica su número de índice. El hecho de que se guarde en el fichero FBM permite extraer un gráfico del fichero FGC, grabarlo como FBM, y que ocupe la misma posición si se importa de nuevo o se copia en otro FGC diferente.</TD></TR> <TR> <TH> MAX FRAME</TH> <TD> DWORD</TD> <TD> Número máximo de frame admitido en este gráfico. Si el gráfico no contiene animación, este valor es 0. En caso contrario, contiene el número de "versiones" diferentes del gráfico que se guardan en el fichero, menos uno (0 para una sola versión, 1 para dos, etc). Un "frame" se refiere simplemente a "gráfico distinto, del mismo tamaño".</TD></TR> <TR> <TH> MAX SEQUENCE</TH> <TD> DWORD</TD> <TD> Número máximo de secuencia de animación contenido en este fichero. Este número equivale al número de animaciones que contiene el FBM, menos uno.</TD></TR> <TR> <TH> MAX KEYFRAME</TH> <TD> DWORD</TD> <TD> Número máximo keyframe de animación contenido en este fichero. Aunque cada secuencia de animación está compuesta de una serie de keyframes de forma idependiente de las demás secuencias, en el fichero FBM se guardan todos los keyframes de todas las animaciones en un array común. Este valor contendrá el número total de keyframes que contiene el FBM, menos uno.</TD></TR> <TR> <TH> MAX POINT</TH> <TD> DWORD</TD> <TD> Máximo valor de índice para un punto de control que contenga el gráfico.</TD></TR> <TR> <TH> POINTS</TH> <TD> DWORD</TD> <TD> Número de puntos de control que hay guardados en este fichero. Un FBM puede tener un sólo punto de control aunque éste tuviese el índice 90, por ejemplo. Este valor se refiere exactamente al número de estructuras de punto de control guardadas más adelante en el FBM. Puede ser cero.</TD></TR></TABLE></P> <H3> Paleta de colores</H3> <P> A continuación, si el gráfico es de 8 bits (tal como indica la cabecera del fichero) y sólo en ese caso, aparecen 768 bytes con la paleta de colores.  Cada color ocupa tres bytes en orden RGB (rojo, verde y azul) y con un rango para cada componente de color de 0 a 255.</P> <H3> Secuencias</H3> <P> A continuación, inmediatamente después de la paleta, si corresponde, o del descriptor en formatos no paletizados, se guardan las secuencias de animación del FBM. Puede haber más de una, pero siempre habrá al menos una. El valor "MAX SEQUENCE" del descriptor indica el número total de secuencias presentes en el fichero, menos una.</P> <P> Cada secuencia de animación ocupa 44 bytes en el fichero, y su estructura es la siguiente: <TABLE> <TR> <TH> NOMBRE</TH> <TD> 32 bytes</TD> <TD> Nombre de la animación, en ASCIIZ. Si ocupa exactamente 32 bytes, el cero terminal no se guarda en el fichero.</TD></TR> <TR> <TH> PRIMER KEYFRAME</TH> <TD> DWORD</TD> <TD> Índice del primer keyframe, en el array global que se guarda en el fichero, de los que componen la animación.</TD></TR> <TR> <TH> ÚLTIMO KEYFRAME</TH> <TD> DWORD</TD> <TD> Índice del último keyframe. Este valor debe ser siempre mayor o igual al anterior (una animación debe contener al menos un keyframe). Además, dos secuencias de animación no pueden compartir un mismo keyframe, ni se permite que hayan keyframes guardados en el fichero que no correspondan a nada.</TD></TR> <TR> <TH> SIGUIENTE SECUENCIA</TH> <TD> INT</TD> <TD> Índice de la secuencia siguiente a esta, o -1 si la secuencia no está enlazada con otra. Una secuencia de animación puede terminar de tres maneras: <UL> <LI> Looping: el número de siguiente secuencia es su propio índice dentro del array de secuencias.</LI> <LI> Stop: este número es -1. Al acabar la animación, ésta se detiene. Esta condición puede comprobarse desde el lenguaje en Fenix, y actuar en consecuencia.</LI> <LI> Link: al acabar la animación, se inicia automáticamente otra dentro del FBM, cuyo índice aparece en este campo.</LI></UL></TD></TR></TABLE></P> <H3> Keyframes</H3> <P> Un keyframe es uno de los "momentos" de los que se compone una animación. Contiene un número de frame y opciones adicionales que pueden emplearse para automatizar tareas comunes enlazadas con la animación, como asignar un ángulo o flags al proceso.</P> <P> Cada keyframe ocupa 16 bytes en el fichero y contiene la siguiente información: <TABLE> <TR> <TH> FRAME</TH> <TD> DWORD</TD> <TD> Índice de frame del gráfico FBM que debe mostrarse</TD></TR> <TR> <TH> ANGLE</TH> <TD> INT</TD> <TD> Ángulo con el cual se mostrará el gráfico. Este ángulo se sumará al indicado en el proceso para obtener el ángulo final de visualización.</TD></TR> <TR> <TH> FLAGS</TH> <TD> DWORD</TD> <TD> Flags de visualización. Estas flags se complementan (con un XOR) con del proceso, por lo que un proceso que dibuje con espejo horizontal un gráfico en cuya animación aparezca un keyframe invertido horizontalmente, se verá correctamente (este keyframe en concreto se verá normal, al anularse mutuamente los dos flags).</TD></TR> <TR> <TH> PAUSA</TH> <TD> DWORD</TD> <TD> Pausa en milisegundos antes del siguiente keyframe. Si este keyframe es el último de la animación, indica el tiempo en milisegundos que deben transcurrir hasta que la animación termine.</TD></TR></TABLE></P> <H3> Puntos de control</H3> <P> A continuación en el fichero se almacenan los puntos de control, tantos como indique el valor PUNTOS en el descriptor. Es posible que esta sección no esté presente si ese valor es cero. En todo caso, cada punto de control es una estructura de 12 bytes que contiene: <TABLE> <TR> <TH> ÍNDICE</TH> <TD> DWORD</TD> <TD> Índice del punto de control, de 0 a 999. El 0 indica centro del gráfico, y si no lo incluye, se considerará su centro geométrico para tal fin.</TD></TR> <TR> <TH> X</TH> <TD> INT</TD> <TD> Coordenada X del punto de control. Puede ser negativa o más grande que el gráfico, pero actualmente el rango soportado es estrictamente entre -32766 y 32766 inclusives.</TD></TR> <TR> <TH> Y</TH> <TD> INT</TD> <TD> Coordenada Y, con las mismas condiciones que X.</TD></TR></TABLE></P> <H3> Datos del gráfico</H3> <P> Por último, aparecen los datos del gráfico propiamente dichos, de arriba a abajo. En primer lugar se guardan todas las filas del primer frame, a continuación todas las filas del segundo, y así hasta almacenar todos los frames del gráfico, hasta el número de índice indicado en el descriptor.</P> <P> En un gráfico de 1 bit por pixel, cada fila incluye <I> padding</I> (bits a 0) hasta ocupar un ancho múltiplo de un byte.</P> <P> En un gráfico de 8 bits el valor 0 está reservado para los pixels transparentes.</P> <P> En un gráfico de 16 bits, cada pixel se guarda en formato RGB565 con el valor 0 reservado para los pixels transparentes (lo cual significa que el color negro puro no puede usarse, siendo necesario sustituirlo por un valor aproximado).</P> <P> En todo caso, cualquier información adicional que aparezca en el fichero después de los datos del gráfico es ignorada. Esto permite realizar extensiones futuras del formato sin perder la compatibilidad hacia atrás.</P> </td></tr> <tr><td> <b>NOTAS</b> </td></tr>
<tr><td style="padding-left: 40pt">Esta es una versión temporal de este formato de fichero. Los gráficos con profundidad de color de 24 bits se soportarán próximamente en los ficheros FBM.</td></tr>
<tr><td> &nbsp; </td></tr>

	</table>
		
</body>
</html>

